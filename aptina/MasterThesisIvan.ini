# INI file for Ivans Master thesis.
# We need to set
#   * the experiment number,
#   * the modality and
#   * the output parameters of the source (kv, mAs and the like)

# For names of classes and attributes see the Aptina atalassian website under
# https://aptina.atlassian.net/wiki/display/DEVS/DevWare+Python

# General stuff which we always need. This preset is executed at INI file load
[Python:]
import os
os.system('clear')
import time

CMOSWidth = apbase.Camera().sensor.width
CMOSHeight = apbase.Camera().sensor.height


def fijioutput():
    print(80 * '-')
    print('Open the RAW files in Fiji as')
    print('   * "16-bit Unsigned" with')
    print('   * a width of', str(CMOSWidth), 'px,')
    print('   * a height of', str(CMOSHeight), 'px and')
    print('   * with "Little-Endian byte order"')
    print(80 * '-')


[Python: Experiment]
os.system('clear')
# Setting up some standard parameters
# "root" directory where we save everything
BaseDirectory = os.path.join('/scratch', 'tmp', 'DevWareX',
                       apbase.Camera().sensor.part_number)
try:
    os.makedirs(BaseDirectory)
except FileExistsError:
    # Don't do anything if the folder already exists
    pass
devware.setoption_str('Capture File', BaseDirectory)

# Show where DevWare saves the stuff and other directories
print('DevWare is running from', apbase.home)
print('The current INI file is loaded from', os.path.dirname(__IniFileName))
print('Images will be saved to', devware.getoption_str('Capture File'))
print()

# Use current POSIX time as experiment ID
ExperimentID = round(time.time()) - 1402000000

# Get experiment parameters
Modality = input(' '.join(['Please input the name of the modality ("Abdomen",',
                           '"Hand", etc.): ']))
print()

# Get source parameters
print('Please input the source parameters you will use for this experiment')
SourcekV = float(input('Source Voltage [kV]:'))
SourcemAs = float(input('Milliampere second [mAs]:'))
SourceExposuretime = float(input('Exposure time of the *source* [ms]:'))

# Get CMOS parameters
WasExposureTime = float(apbase.getstate('HW Exposure Time'))
print('Current *CMOS* exposure time is', round(WasExposureTime * 1000, 3),
       'ms')
manual = 1
if manual:
    DesiredExposureTime = float(input('Desired Exposure Time [ms]: ')) / 1000
else:
    ReadOutFrequency = 15
    print('Setting Exposure time to Maximum of what we can get at',
           ReadOutFrequency, 'Hz')
    DesiredExposureTime = (1 / ReadOutFrequency)
print('Setting Exposure time to', DesiredExposureTime, 's')
apbase.setstate('HW Exposure Time', str(DesiredExposureTime))
# Grab some frames from the buffer to make sure the exposure time is correct
for i in range(5):
    Return, Image = apbase.Camera().grab_frame()
CMOSExposuretime = float(apbase.getstate('HW Exposure Time'))
print('Exposure time has been set to', round(CMOSExposuretime * 1000, 3),
       'ms')

# Inform the user about what goes where.
print(80 * '-')
SaveDirectory = os.path.join(BaseDirectory, Modality)
devware.setoption_str('Capture File', SaveDirectory)
FilePrefix = '_'.join([Modality, str(ExperimentID),
                       str(CMOSWidth) + 'x' + str(CMOSHeight),
                       str(SourcekV) + 'kV',
                       str(SourcemAs) + 'mAs',
                       str(SourceExposuretime) + 'msSource',
                       str(round(CMOSExposuretime * 1000, 3)) + 'msCMOS'])
print('Images of experiment ID', str(ExperimentID),
       'will be saved to the directory',
       str(devware.getoption_str('Capture File')))
print('as', FilePrefix + '* RAW images')
print()

# Give the user some time to set up and inform about
RecordingTime = int(input('How long would you like to record images? [s]:'))

# Ask for how long we should record? Gives NumberOfImages, fps, etc.
NumberOfImages = int(round(RecordingTime * 1000 / CMOSExposuretime))
print('You want to grab images with', round(CMOSExposuretime * 1000, 3),
       'ms exposure time corresponding to approximately',
       int(round(1 / (CMOSExposuretime))), 'fps.')
print('During', RecordingTime, 's, this will give a total of',
    int(round(RecordingTime / CMOSExposuretime)),
    'images (if we could save at "infinite" speed).')
#~ if 1 / (DesiredExposureTime / 1000) > 8:
    #~ print('I reduce the amount of recorded images to match the maximally',
        #~ 'achievable 7.5 fpsso that you do not have to wait for',
        #~ round(NumberOfImages / 7.5, 3), 's (instead of the requested',
        #~ RecordingTime, 's).')
    #~ NumberOfImages = int(round(RecordingTime * 8))  # fps
    #~ print('You could go as high as 134 ms with the exposure time to match',
        #~ 'exposure and readout time.')
    #~ time.sleep(1)

# Save images and do some timing on the way
StartTime = time.time()
while StartTime + RecordingTime < time.time():
    print('Go!!!', time.time())
    time.sleep(0.1)
print('DONE!!!')


#~
#~
#~ for i in range(NumberOfImages):
    #~ s = time.time()
    #~ # Grab the frame
    #~ Return, Image = apbase.Camera().grab_frame()
    #~ # Save it to a nicely named file
    #~ Filename = Suffix + '_' + str(i + 1).zfill(len(str(NumberOfImages))) +\
        #~ '.raw'
    #~ with open(os.path.join(SaveDir, Filename), 'wb') as f:
        #~ f.write(Image)
    #~ e = time.time()
    #~ # Log some stuff to the console
    #~ print(str(i).zfill(len(str(NumberOfImages))) + '/' +
        #~ str(NumberOfImages) + ': Exposing for', round(DesiredExposureTime),
        #~ 'ms and saving @', round((1 / (e - s)), 1), 'fps.')
#~ print(80 * '-')
#~ EndTime = time.time()
#~ # Inform the user about what happened.
#~ print('The whole process took me', round(EndTime - StartTime, 3),
       #~ 's. You requested', RecordingTime, 's.')
#~ print(80 * '-')
#~
#~ # Get the sensor back to the initial state
#~ apbase.setstate('hw exposure time', str(WasExposureTime))
#~ IsExposureTime = float(apbase.getstate('HW Exposure Time'))
#~ print('Setting exposure time back to', round(IsExposureTime * 1000, 3),
    #~ 'ms, which should be the same as it was before we started, namely',
    #~ str(round(WasExposureTime * 1000, 3)), 'ms.')
#~ print(80 * '-')
#~
#~ # Final output
#~ fijioutput()
#~
#~
#~ [Python: Acquire X images over a given rail distance]
#~ os.system('clear')
#~ # Grab and save current state of chip
#~ WasExposureTime = float(apbase.getstate('HW Exposure Time'))
#~ print('Currently, the chip is exposing for', round(WasExposureTime * 1000, 3),
    #~ 'ms, saving this value for later.')
#~
#~ # Ask the user for the desired exposure time and set it
#~ DesiredExposureTime = float(input('Desired exposure time [ms]: '))
#~ apbase.setstate('hw exposure time', str(DesiredExposureTime / 1000.0))
#~ # Grab some images from the buffer to make the exposure time stick
#~ for i in range(5):
    #~ Return, Image = apbase.Camera().grab_frame()
#~ CurrentExposureTime = float(apbase.getstate('HW Exposure Time'))
#~ print('Exposure time set to', round(CurrentExposureTime * 1000, 3), 'ms.')
#~
#~ # Ask the user for what distance he/she'd like to record. And for how many
#~ # steps, with which lens, at what focus and what aperture, so we can write this
#~ # info in the files
#~ Lens = input('Which lens are you using?: ')
#~ Focus = float(input('What is the focus value on the lens? (0 if none): '))
#~ Aperture = float(input('What is the aperture? (0 if none): '))
#~
#~ print
#~ Position = []
#~ Position.append(float(input(' '.join(['Where do you want to *start* on the',
    #~ 'rail? [mm]: ']))))
#~ Position.append(float(input(' '.join(['Where do you want to *stop* on the',
    #~ 'rail? [mm]: ']))))
#~ # Round the positions to the nearest mm. And make the positions 'int', so we
#~ # can use them later on in the range(Position[0], Position[1]) calls
#~ Position = [int(round(i)) for i in Position]
#~
#~ if Position[0] == Position[1]:
    #~ print('You have to move at least a bit, i.e. the starting and end',
        #~ 'Position have to be different. Increasing the total distance by 1',
        #~ 'cm.')
    #~ Position[1] += 10
#~ elif Position[0] >= Position[1]:
    #~ # Flip start and end, so that we always start close to the Scintillator
    #~ Position[0], Position[1] = Position[1], Position[0]
#~
#~ StepNumber = int(input(' '.join(['How many steps would you like to image',\
    #~ '*between*', str(Position[0]), 'mm and', str(Position[1]), 'mm?: '])))
#~ if StepNumber > 25:
    #~ print('Are you sure you want to record', StepNumber, 'steps?')
    #~ StepNumber = int(input(' '.join(['If you want, you can enter a smaller',
        #~ 'number of steps...'])))
#~
#~ if int(round(Position[1] - Position[0]) / StepNumber) < 1:
    #~ print('These settings would lead to steps smaller than 1mm, I am',
        #~ 'decreasing the number of steps from', StepNumber, 'to',
        #~ int(Position[1] - Position[0]), 'so that we can do these steps with a',
        #~ '1mm step width between each shot.')
    #~ StepNumber = Position[1] - Position[0]
#~
#~ print(80 * '-')
#~ # Prepare output directory and set it in DevWareX
#~ # Grab the current second to make the folders distinguishable, even for exactly
#~ # the same parameters
#~ Timer = int(time.time())
#~ Suffix = apbase.Camera().sensor.part_number + '_' + \
    #~ str(apbase.Camera().sensor.width) + 'x' + \
    #~ str(apbase.Camera().sensor.height) + '_' + Lens + '_' + str(Focus) + \
    #~ '_' + str(Aperture) + 'f_' + \
    #~ str(int(CurrentExposureTime * 1000)).zfill(3) + 'ms_' + \
    #~ str(Position[0]).zfill(3) + 'mm_to' + str(Position[1]).zfill(3) + 'mm'
#~
#~ SaveDir = os.path.join('/scratch', 'tmp', 'DevWareX',
                       #~ apbase.Camera().sensor.part_number,
                       #~ 'LensSeries_' + str(Lens), str(Timer) + '_' + Suffix)
#~ try:
    #~ os.makedirs(SaveDir)
#~ except FileExistsError:
    #~ print(SaveDir, 'already exists, proceeding')
#~ devware.setoption_str('Capture File', SaveDir)
#~ print('Saving the', StepNumber, 'Images to',
    #~ devware.getoption_str('Capture File'))
#~ print(80 * '-')
#~
#~ # Step through the chosen positions
#~ input(' '.join(['Move the slider to', str(Position[0]), 'mm and press',
    #~ '"Enter" to continue']))
#~ SleepyTime = 8
#~
#~ RailPositions = [i for i in range(Position[0], Position[1] + 1,
                 #~ int(round((Position[1] - Position[0]) / (StepNumber + 1))))]
#~
#~ for i, CurrentPosition in enumerate(RailPositions):
    #~ print(10 * '-', 'Step', str(i + 1) + '/' + str(len(RailPositions)),
        #~ 50 * '-')
    #~ print ('Move slider to', CurrentPosition, 'mm and get ready to expose',
        #~ 'with', round(CurrentExposureTime * 1000, 3), 'ms')
    #~ print('Ready ',)
    #~ time.sleep(SleepyTime / 3)
    #~ print('Set ',)
    #~ time.sleep(SleepyTime / 3)
    #~ print('Go!')
    #~ time.sleep(SleepyTime / 3)
    #~ Return, Image = apbase.Camera().grab_frame()
    #~ # Save it to a nicely named file
    #~ Filename = Suffix + '_' + str(CurrentPosition).zfill(3) + 'mm.raw'
    #~ with open(os.path.join(SaveDir, Filename), 'wb') as f:
        #~ f.write(Image)
    #~ print ('Image saved to', os.path.basename(Filename))
#~
#~ print(80 * '-')
#~ # Get the sensor back to the initial state
#~ apbase.setstate('hw exposure time', str(WasExposureTime))
#~ IsExposureTime = float(apbase.getstate('HW Exposure Time'))
#~ print('Setting exposure time back to', round(IsExposureTime * 1000, 3),
    #~ 'ms, which should approximately be the same as it was before we started,',
    #~ 'namely', str(round(WasExposureTime * 1000, 3)), 'ms.')
#~ print(80 * '-')
#~ # Final output
#~ fijioutput()
#~
#~ [Python: Capture Exposure time range]
#~ os.system('clear')
#~ WasExposureTime = float(apbase.getstate('HW Exposure Time'))
#~ print('Exposure time was set to', round(WasExposureTime * 1000, 3), 'ms')
#~ MinimalExposureTime = int(round(float(input(' '.join(['Please input desired',
                                                      #~ 'minimal exposure time',
                                                      #~ '[ms]: '])))))
#~ MaximalExposureTime = int(round(float(input(' '.join(['Please input desired',
                                                      #~ 'maximal exposure time',
                                                      #~ '[ms]: '])))))
#~ if MaximalExposureTime > 2080:
    #~ print('The Aptina chip cannot expose for longer than 2 seconds,',
    #~ 'capping exposure time there.')
    #~ MaximalExposureTime = 2080
#~ ExposureTimeStep = int(round(float(input('Please input step width [ms]: '))))
#~ if ExposureTimeStep == 0:
    #~ # User entered a value that was rounded off to 0
    #~ ExposureTimeStep = 1
#~ print('We cannot set fractions of ms, so your inputs were rounded to the',
    #~ 'next integer. We are using')
#~ print('   * a minimal exposure time of', MinimalExposureTime, 'ms')
#~ print('   * a maximal exposure time of', MaximalExposureTime, 'ms')
#~ print('   * and exposure time steps of', ExposureTimeStep, 'ms')
#~ ExposureTimes = [i for i in range(MinimalExposureTime,
                                   #~ MaximalExposureTime + ExposureTimeStep,
                                   #~ ExposureTimeStep)]
#~ StartTime = int(round(time.time()))
#~ SaveDir = os.path.join('/scratch', 'tmp', 'DevWareX',
                       #~ apbase.Camera().sensor.part_number,
                       #~ 'ExposureSeries_' + str(StartTime) + '_' + \
                       #~ str(MinimalExposureTime) + 'ms_to_' + \
                       #~ str(MaximalExposureTime) + 'ms')
#~ try:
    #~ os.makedirs(SaveDir)
#~ except FileExistsError:
    #~ print(SaveDir, 'already exists, proceeding')
#~ print(80 * '-')
#~ print('Saving images to', SaveDir)
#~ print('Grabbing image with an exposure time of:')
#~ for exp in ExposureTimes:
    #~ apbase.setstate('hw exposure time', str(exp / 1000))
    #~ IsExposureTime = round(float(apbase.getstate('hw exposure time')) * 1000,
                           #~ 2)
    #~ print(str(ExposureTimes.index(exp) +
               #~ 1).rjust(len(str(len(ExposureTimes)))) + '/' +
           #~ str(len(ExposureTimes)) + ': Exposure time of',
           #~ '{:.2f}'.format(IsExposureTime), 'ms')
    #~ # we need to read some images to clear the buffer
    #~ for i in range(5):
        #~ Return, Image = apbase.Camera().grab_frame()
    #~ # Save the files to some recognisable filename.
    #~ # use 'format' to have trailing and 'zfill' to have leading zeroes
    #~ Filename = str(StartTime) + '_exp_' + \
        #~ '{:.2f}'.format(IsExposureTime).zfill(3 + \
                                              #~ len(str(MaximalExposureTime))) +\
        #~ 'ms.raw'
    #~ with open(os.path.join(SaveDir, Filename), 'wb') as f:
        #~ f.write(Image)
#~ print(80 * '-')
#~ apbase.setstate('hw exposure time', str(WasExposureTime))
#~ IsExposureTime = float(apbase.getstate('HW Exposure Time'))
#~ print('Setting exposure time back to', round(IsExposureTime * 1000, 3),
    #~ 'ms, which should be the same as it was before we started, namely',
    #~ str(round(WasExposureTime * 1000, 3)), 'ms.')
#~ fijioutput()
#~
#~
#~ [Python: Lens Sensor Iteration]
#~ os.system('clear')
#~
#~ # Grab and save current state of chip
#~ print('Working with the sensor', apbase.Camera().sensor.part_number,
    #~ 'at the moment')
#~ ExposureTime = float(apbase.getstate('HW Exposure Time'))
#~ print('Current (automatic) exposure time is', round(ExposureTime * 1000, 3),
    #~ 'ms')
#~ Distance = float(input(' '.join(['What is the distance between the',
    #~ '"scintillator" and the *head* board? [mm]: '])))
#~ Lens = input('Which lens did you mount?: ')
#~ Focus = float(input(' '.join(['What is the focal distance you set on the',
    #~ 'lens? Enter "0" if none given and set to "best" focus for covering the',
    #~ 'full star: '])))
#~ Aperture = float(input(' '.join(['What is the aperture you set on the lens?',
    #~ 'Enter "0" if none can be set: '])))
#~
#~ # Prepare output directory and set it in DevWareX
#~ SaveDir = os.path.join('/scratch', 'tmp', 'DevWareX',
                       #~ apbase.Camera().sensor.part_number, 'LensIteration')
#~ try:
    #~ os.makedirs(SaveDir)
#~ except FileExistsError:
    #~ print(SaveDir, 'already exists, proceeding')
#~ devware.setoption_str('Capture File', SaveDir)
#~
#~ FileName = apbase.Camera().sensor.part_number + '_' + \
    #~ str(apbase.Camera().sensor.width) + 'x' + \
    #~ str(apbase.Camera().sensor.height) + '_' + str(Lens) + '_' + \
    #~ str(Distance) + 'mm_' + str(Focus) + '_' + str(Aperture) + 'f_' +  \
    #~ str(int(ExposureTime * 1000)).zfill(3) + 'ms.raw'
#~
#~ print('Saving the focus and FOV image as', FileName, 'to',
    #~ devware.getoption_str('Capture File'))
#~
#~ print(80 * '-')
#~
#~ # Grab some images from the buffer to make sure we got a nice one to save
#~ for i in range(5):
    #~ Return, Image = apbase.Camera().grab_frame()
#~ # Grab another one and save it to a nicely named file
#~ Return, Image = apbase.Camera().grab_frame()
#~ with open(os.path.join(SaveDir, FileName), 'wb') as f:
    #~ f.write(Image)
#~ print ('Written image to', FileName)
#~ print(80 * '-')
